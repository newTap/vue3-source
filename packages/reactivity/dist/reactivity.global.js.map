{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/constants.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export const isObject =  (value:unknown) => typeof value === 'object' && value !== null\n\nexport const isFunction = (value:unknown): value is Function => typeof value === 'function'\n\nexport const isArray = Array.isArray\n\nexport const isString = (val: unknown): val is string => typeof val === 'string'\n\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\n\nexport const isObj = (val:unknown): val is object => (!!val) && (typeof val === 'object')\n\nexport const isIntegerKey = (key: unknown) =>  isString(key)&&key[0]!='_'&&parseInt(key, 10)+'' === key\n\nexport const hasOwn = (target: object, key: string | symbol): boolean => target.hasOwnProperty(key)\n\nexport const hasChange = (value:unknown, oldValue:unknown) => value !== oldValue\n\nexport const isRef = (val: any) => !!val.__v_isRef","import { isArray, isSymbol } from \"@vue/shared\";\nimport { TrackOpTypes, TriggerOpTypes } from \"./constants\";\n\ntype EffectOptions = {\n lazy?: boolean\n sch?:() => void\n}\n\ntype ActiveEffectType= {\n    (): void;\n    fn: () => void;\n    options: EffectOptions | undefined;\n    id: number;\n    _isEffect: boolean;\n}\n\nlet uid = 0;\n// 用于记录当前正在执行的副作用函数\nlet activeEffect: ActiveEffectType;\n// 用户基于当前正在执行的副作用函数队列\n// !如果不适用队列形式存储，会导致effect嵌套时，activeEffect无法被正确获取\n// effect(function () {\n//   let name = proxy.name\n//   effect(function () {\n//     let name = proxy.name\n//   })\n//   let list = proxy.list\n// })\nlet activeEffectPool: ActiveEffectType[] = []\n\n// 副作用函数的触发\nexport function effect (fn: () => void, options?: EffectOptions):ActiveEffectType{\n  const effectFn = function reactiveEffect(){\n    // 防止effect函数的的报错，对代码逻辑的影响\n    try{\n      activeEffect = effectFn\n      activeEffectPool.push(activeEffect)\n      return fn()\n    }finally{\n      activeEffectPool.pop()\n      activeEffect = activeEffectPool[activeEffectPool.length - 1]\n    }\n  }\n\n  effectFn.fn = fn // 保存用户的原方法\n  effectFn.options = options // 保存用户的原配置\n  effectFn.id = uid++ // effect 的ID\n  effectFn._isEffect = true // 标记是否为 effect\n  if(!options?.lazy) effectFn();\n  return effectFn\n}\n\ntype Deps =  Set<ActiveEffectType>\n\ntype KeyToDepMap = Map<any, Deps>\n\n// 用于存储依赖的集合\nconst targetActiveMap = new WeakMap<object, KeyToDepMap>()\n// 依赖的收集\nexport function track(target:object, key: string | symbol, type: TrackOpTypes){\n  console.log('开始收集依赖')\n  // 只有在副作用函数调用期间才做依赖的收集\n  if(!activeEffect) return false\n\n  // 依赖集合的数据结构，第一层使用WeakMap，利用它的弱引用\n  // target作为key值，依赖集合作为value值\n  let targetMap = targetActiveMap.get(target)\n  if(!targetMap) targetActiveMap.set(target, (targetMap = new Map()))\n  // 第二层使用Map数据结构\n  // key作为key值，依赖集合作为value值\n  let dep = targetMap.get(key)\n  // 第三层使用Set数据结构,当相同数据添加值set中会做自动去重操作\n  // 用于存放对应的副作用函数\n  if(!dep) targetMap.set(key, (dep = new Set()))\n\n  // 为对应的key添加副作用函数\n  dep.add(activeEffect)\n}\n\n// 依赖是触发\nexport function trigger(target:object, key: string | symbol, type: TriggerOpTypes, value: unknown, oldValue: unknown){\n  let targetMap = targetActiveMap.get(target)\n  console.log('targetActiveMap', targetActiveMap, target, key, value)\n  // 当前的修改没有依赖\n  if(!targetMap) {\n    console.log('没有当前的target依赖映射', target)\n    return false\n  }\n  let deeps:Deps[] = []\n\n  if(isArray(target) && key === 'length'){\n    // 单独对修改数组的length操作做处理\n    // !当proxy对象没有代理length属性，却修改了数组的length，会导致没有对应的依赖\n    //  effect(function () {\n    //   app.innerText = `${proxy.list[2]}`\n    // })\n    // setTimeout(() => {\n    //   proxy.list.length = 1\n    // }, 1000)\n    // 如果target是数组。并且当前的key是length。value的值大于target的length\n    // 证明数组的长度发生了变化(变小了)\n    targetMap.forEach((dep, key) => {\n      if(key === 'length' || (!isSymbol(key) &&  Number(key) >= Number(value))){\n        deeps.push(dep)\n      }\n    });\n  }else{\n    // 可能是对象的操作\n    let dep = targetMap.get(key)\n    if(dep){\n      deeps.push(dep)\n    }\n  }\n  for (let dep of deeps) {\n    if(dep){\n      triggerEffects(dep)\n    }\n  }\n}\n\nfunction triggerEffects(dep:Deps){\n  for (const effect of dep.keys()) {\n    // computed函数携带的特俗字段sch\n    // computed函数会根据get字段来调用对应的effect，所以不需要再trigger中调用\n    if(effect.options?.sch){\n      effect.options?.sch()\n    }else{\n       effect()\n    }\n  }\n}","export enum TrackOpTypes {\n  GET = 'get',\n  HAS = 'has',\n}\n\nexport enum TriggerOpTypes {\n  SET = 'set',\n  ADD = 'add',\n}","import { hasOwn, isArray, isIntegerKey, isObject } from \"@vue/shared\"\nimport { reactive, readonly } from \"./reactive\"\nimport { track, trigger } from \"./effect\"\nimport { TrackOpTypes, TriggerOpTypes } from \"./constants\"\n\nconst get = createGetter()\nconst readonlyGet = createGetter(true)\nconst shallowReactiveGet = createGetter(false, true)\nconst shallowReadonlyGet = createGetter(true, true)\n\nconst set = createSetter()\nconst shallowSet = createSetter(true)\n\nexport const reactiveHandler = {\n  get,\n  set\n}\n\nexport const readonlyHandler = {\n get: readonlyGet,\n set: function(){\n  console.error('只读无法修改')\n  return false\n }\n}\n\nexport const shallowReactiveHandler = {\n  get: shallowReactiveGet,\n  set: shallowSet\n}\n\nexport const shallowReadonlyHandler = {\n  get: shallowReadonlyGet,\n  set: function(){\n   console.error('只读无法修改')\n   return false\n  }\n}\n\nfunction createGetter(isReadonly = false, isShallow = false) {\n  return function get (target: object, key:string|symbol, receiver: object) {\n      console.log(`get: `, key)\n      const res = Reflect.get(target, key, receiver)\n      // 收集 effect\n      if(!isReadonly){\n        console.log('收集 effect')\n        track(target, key, TrackOpTypes.GET)\n      }\n      // 递归处理,为了实现深层次的响应式\n      //! 只有调用到了get方法，才会进行递归，并没有将所有的子对象递归。属于优化\n      if(!isShallow && isObject(res)) {\n        console.log('调用递归', res)\n        // !保证返回的对象是一个代理对象\n        // !否则在第一次进行set操作的时候，会导致无法监听到set的操作\n        return isReadonly? readonly(res as object) : reactive(res as object)\n      }\n      return res\n    }\n}\n\nfunction createSetter(isShallow = false){\n  return function set(target:object,key:string | symbol, value: unknown, receiver:object) {\n      console.log(`set: `, key,  value, target)\n      // !当对数组做操作(删除,或增加)，会先调用对应下标的set操作，然后再调用length的set操作\n      // !当对数组做操作时，对应的key会被处理为string类型\n      // !当对数组的length直接做操作时，会直接调用length的set操作，无法触发对应下标的set操作\n\n      // 1.先区分属于与对象的操作\n      // 2.再区分是修改操作，还是增加操作\n      let hasKey = isArray(target) && isIntegerKey(key)?\n       Number(key) < target.length : hasOwn(target, key)\n      let oldValue = (target as any)[key]\n\n      let ref = Reflect.set(target,key, value, receiver)\n\n    // 执行 effect\n      if(hasKey){\n        // 修改操作\n        console.log('修改操作')\n        trigger(target, key, TriggerOpTypes.SET, value, oldValue)\n      }else{\n        // 新增操作\n        console.log('新增操作')\n        trigger(target, key, TriggerOpTypes.ADD, value, oldValue)\n      }\n\n      return ref\n    }\n}","import { isObject } from \"@vue/shared\";\nimport { reactiveHandler, readonlyHandler, shallowReactiveHandler, shallowReadonlyHandler } from \"./baseHandlers\";\n\nexport type targetType<T> = T;\n// 使用WeakMap存储代理对象\n// WeakMap的键是弱引用，不会影响垃圾回收\nconst reactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\n/**\n * reactive\n *\n * [export description]\n *\n * 响应式转换是\"成层\"的: 他会影响到所有嵌套的属性。\n *\n * \"深层\"次的响应代理\n *\n * @param   {T}          data  [需要代理的对象]\n *\n * @return  {<T><data>}        [返回一个对象的响应式代理。]\n */\nexport function reactive<T extends object>(data:T):object{\n  return createReactiveObject(data, false, false, reactiveHandler)\n} \n/**\n * [export description]\n *\n * 只读代理是深层的：对任何嵌套属性的访问都将是只读的\n *\n * \"深层\"次的响应代理，只读\n *\n * @param   {T}          data  [接受一个对象 (不论是响应式还是普通的) 或是一个 ref，]\n *\n * @return  {<T><data>}        [return 返回一个原值的只读代理]\n */\nexport function readonly<T extends object>(data:T):object{\n  return createReactiveObject(data, true , false, readonlyHandler)\n}\n\n/**\n * [export description]\n *\n * reactive() 的浅层作用形式。\n * 这里没有深层级的转换：一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露\n *\n * \"浅层\"次的响应代理\n *\n * @param   {T}          data  [data 需要代理的对象]\n *\n * @return  {<T><data>}        [return 一个没有深度代理的响应对象]\n */\nexport function shallowReactive<T extends object>(data:T):object{\n  return createReactiveObject(data, true, false, shallowReactiveHandler)\n}\n\nexport function shallowReadonly<T extends object>(data:T):object{\n  return createReactiveObject(data, true, false, shallowReadonlyHandler)\n}\n\n/**\n * [createReactiveObject description]\n *\n * @param   {T}  data        [监听的数据对象]\n * @param   {[type]}isReadonly  [是否只读]\n * @param   {[type]}isShallow   [是否深层代理]\n *\n * @return  {T}              [return 数据的代理对象]\n */\nfunction createReactiveObject<T extends object>(data:T, isReadonly=false, isShallow=true, handlers:ProxyHandler<T>):T {\n  // 非对象类型直接返回\n  if(!isObject(data)) {\n    console.error('请给一个对象')\n    return data;\n  }\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap\n  // 校验是否已有代理对象\n  if(proxyMap.has(data)) return proxyMap.get(data);\n  // 若目标已经是一个代理对象，则需要返回该对象 待完善\n\n  const proxy =  new Proxy(data, handlers);\n  proxyMap.set(data, proxy)\n  return proxy\n}","import { hasChange, isArray, isObj, isRef } from \"@vue/shared\"\nimport { TrackOpTypes, TriggerOpTypes } from \"./constants\"\nimport { track, trigger } from \"./effect\"\nimport { reactive } from \"./reactive\"\nimport { isObject } from '../../shared/src/index';\n\n/**\n * 接受一个内部值，返回一个响应式的，可更改的ref对象，此对象只有一个指向内部的属性.value\n *\n * 如果将一个对象赋值给 ref，那么这个对象将通过 reactive() 转为具有深层次响应式的对象。\n *\n * @param   {unknown}  target  [target 任意数据]\n *\n * @return  {[type]}           [return 一个ref对象]\n */\nexport function ref(target: unknown){\n  return createRef(target)\n}\n\n/**\n * 也可以基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。\n * \n * target 传入单个数据，则直接变成响应式数据对象\n * \n * target 和 key都存在的话，target必须是响应式数据对象\n * \n * const state = reactive({\n  *foo: 1,\n * bar: 2\n  *})\n  *const stateAsRefs = toRefs(state)\n  *stateAsRefs 的类型：{\n    *foo: Ref<number>,\n    *bar: Ref<number>\n  *}\n *\n * @param   {unknown}  target  [target 一个代理对象]\n *\n * @return  {[type]}           [return 一个ref对象]\n */\nexport function toRef(target: unknown, key?: string){\n  return createToRef(target, key)\n}\n\n\n/**\n * 将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。\n *\n * @param   {unknown}  target  [target description]\n *\n * @return  {[type]}           [return description]\n */\nexport function toRefs<T extends object>(target: T){\n  // 如果传入的不是一个基础数据类型，则警告\n  // 如果传入的是一个ref的类型，但是value是一个基础数据类型，则警告\n  if(!isObj(target) || (isRef(target) && (!isObj((target as any).__value)))){\n    console.error(\"传入的必须是一个对象\")\n  }\n\n  const map = isArray(target) ? new Array(target.length) : {}\n\n  Object.keys(target).forEach((key: string) => {\n    (map as any)[key] = createToRef(target, key)\n  })\n\n  return map\n}\n\n\n\nfunction createRef(target: unknown){\n  if(isRef(target)) return target\n  return new RefImpl(target)\n}\n\nclass RefImpl<T> {\n  private _value:T\n  private _rawValue:T\n  private __v_isShallow: boolean\n  private readonly __v_isRef:boolean = true\n  constructor(target: T, isShallow:boolean = false){\n    console.log('isObj(target)', isObj(target))\n  if(isObj(target)){\n      // 若是对象，则需要通过reactive来收集依赖\n      // !若是对象，对其属性修改，将无法触发内部的 setter函数，必须使用reactive来实现数据响应式\n      let proxy = reactive(target)\n      this._value = proxy as T\n      this._rawValue = proxy as T\n    }else{\n      this._value = target\n      this._rawValue = target\n      // 普通数据类型，直接收集依赖\n    }\n   \n    this.__v_isShallow = isShallow\n  }\n\n  get value() {\n    // 依赖收集\n    track(this, 'value', TrackOpTypes.GET)\n    return this._value\n  }\n\n  set value(value){\n    if(hasChange(this._value, value)){\n      const oldValue = this._rawValue\n      // 判断新值是否是对象类型\n      // 如果是对象类型。则将该对象类型转换为响应式数据\n      const newValue = isObj(value)?reactive(value): value\n\n      this._value = newValue as T\n      this._rawValue = newValue as T\n\n      // 触发器\n      trigger(this, 'value', TriggerOpTypes.SET, newValue, oldValue)\n    }\n  }\n}\n\nfunction createToRef(target: unknown, key?: string){\n  if(isRef(target)) return target\n  else if(isObject(target) && key) {\n     return  new ObjectRefImpl(target, key)\n  }else{\n    return ref(target)\n  }\n}\n\nclass ObjectRefImpl<T>{\n  private __v_isShallow = false\n  private readonly __v_isRef:boolean = true\n  constructor(private _target:T, private _key:string){\n  }\n\n  get value(){\n    // 直接调用target的get，来捕获依赖\n    return (this._target as any)[this._key]\n  }\n\n  set value(value){\n    // 直接调用target的set，来触发依赖\n    (this._target as any)[this._key] = value\n  }\n}","\nimport { hasChange, isFunction } from \"@vue/shared\"\nimport { effect } from \"./effect\"\n\ntype Getter<T> = () => T\ntype Setter<T> = (value: T) => void | undefined\ntype Options<T> = {\n  get: Getter<T>\n  set?:Setter<T>\n}\ntype SetOrOptions<T> = Options<T> | Getter<T>\n\n/**\n * 接受一个 getter 函数，返回一个只读的响应式 ref 对象。\n * 该 ref 通过 .value 暴露 getter 函数的返回值。\n * 它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。\n *\n * 特性：\n * 只有被读取的时候，computed 计算属性才会被执行\n * 当computed被执行后，会有缓存，所以多次调用computed不会执行多次\n * 只有当依赖的响应式对象发生改变时，才会重新执行\n *\n * @return  {[type]}  [return description]\n */\nexport function computed<T>(setOrOptions:  SetOrOptions<T>){\n  let getter:Getter<T>,setter: Setter<T> | undefined\n  if(isFunction(setOrOptions)){\n    getter = setOrOptions\n  }else{\n    getter = setOrOptions.get\n    setter = setOrOptions.set\n  }\n\n  return new ComputedRefImpl(getter, setter)\n}\n\nclass ComputedRefImpl<T>{\n  private _dirty:boolean = true\n  private _value: any\n  private _effect\n  constructor(private _getter: Getter<T>, private readonly _setter?:Setter<T>){\n    // !由于是使用的响应式数据，对数据的操作会触发对应的track和trigger函数\n    // !但是我们没有对应的副作用函数(effect)，所以当触发trigger的时候，没有对应的副作用操作\n    // !所以我们需要添加一个副作用函数(effect),在trigger的时候修改_dirty字段，并且在重新调用get时去执行对应的副作用函数\n    this._effect =  effect(_getter,{lazy: true,\n          sch:() => {\n            if(!this._dirty) this._dirty = true\n        } })\n    }\n\n  get value (){\n    // 当dirty为true时，表示需要跟新值，为false时从缓存的取值\n    if(this._dirty){\n      // 需要更新数据，直接调用副作用函数\n      this._value =  this._effect()\n      this._dirty = false\n    }\n    return this._value\n  }\n\n  // !当值给了get函数的情况下，修改动态数据之后，是无法调用这个set方法。\n  // !由于computed函数内使用的是响应式数据，所以依然会触发proxy的set方法来触发对应的trigger函数\n  set value (newValue:T){\n    if(hasChange(newValue, this._value)){\n      this?._setter && this._setter(newValue)\n    }\n  }\n}"],"names":[],"mappings":"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"}